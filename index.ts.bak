import { Type } from "@sinclair/typebox";
import * as fs from "node:fs";
import * as path from "node:path";
import * as os from "node:os";
import * as crypto from "node:crypto";

// === é…ç½®ä¸å¸¸é‡ ===
const GLOBAL_MEMORY_DIR = path.join(os.homedir(), ".pi-memory");
const DB_PATH = path.join(GLOBAL_MEMORY_DIR, "memories.db");
const CACHE_DIR = path.join(GLOBAL_MEMORY_DIR, ".cache");

const CONFIG = {
  embeddingModel: "Xenova/nomic-embed-text-v1",
  embeddingDimensions: 768,
  maxDistance: 1.2, // å‘é‡ç›¸ä¼¼åº¦é˜ˆå€¼
  maxMemories: 10,
};

// === è¾…åŠ©å‡½æ•°ï¼šé¡¹ç›®æŒ‡çº¹ç”Ÿæˆ ===
function getProjectHash(cwd: string): string {
  return crypto.createHash("md5").update(cwd).digest("hex");
}

function ensureDir(dir: string) {
  if (!fs.existsSync(dir)) fs.mkdirSync(dir, { recursive: true });
}

// === å»¶è¿ŸåŠ è½½æ¨¡å— ===
let Database: any = null;
let sqliteVec: any = null;
let pipeline: any = null;
let transformersEnv: any = null;
let embeddingPipeline: any = null;
let db: any = null;

async function loadDependencies() {
  if (Database && sqliteVec && pipeline) return;
  const betterSqlite = await import("better-sqlite3");
  Database = betterSqlite.default;
  sqliteVec = await import("sqlite-vec");
  const transformers = await import("@xenova/transformers");
  pipeline = transformers.pipeline;
  transformersEnv = transformers.env;
  transformersEnv.allowLocalModels = true;
  transformersEnv.allowRemoteModels = true;
  transformersEnv.cacheDir = CACHE_DIR;
}

// === æ•°æ®åº“åˆå§‹åŒ– (è‡ªåŠ¨è¿ç§» Schema) ===
async function initDB() {
  if (db) return db;
  await loadDependencies();
  ensureDir(GLOBAL_MEMORY_DIR);
  db = new Database(DB_PATH);
  sqliteVec.load(db);

  // 1. åˆ›å»ºåŸºç¡€è¡¨ (V3.0 Schema)
  db.exec(`
    CREATE TABLE IF NOT EXISTS memories (
      id TEXT PRIMARY KEY,
      content TEXT NOT NULL,
      tags TEXT,
      
      -- V3.0 æ–°å¢å­—æ®µ
      scope TEXT DEFAULT 'local',       -- 'global' | 'local'
      project_id TEXT,                  -- é¡¹ç›®è·¯å¾„Hash (ä»… local æœ‰æ•ˆ)
      status TEXT DEFAULT 'active',     -- 'active' | 'archived' | 'rejected'
      parent_id TEXT,                   -- æ¼”åŒ–é“¾ï¼šå‰èº«ID
      change_reason TEXT,               -- å˜æ›´/å½’æ¡£ç†ç”±
      source TEXT DEFAULT 'user',       -- 'user_explicit' | 'user_implicit' | 'ai_inference'
      confidence REAL DEFAULT 1.0,      -- ç½®ä¿¡åº¦ 0.0-1.0
      access_count INTEGER DEFAULT 0,   -- è°ƒç”¨æ¬¡æ•°
      last_accessed_at INTEGER,         -- æœ€åæ¿€æ´»æ—¶é—´
      
      created_at INTEGER NOT NULL,
      updated_at INTEGER NOT NULL
    );
  `);

  // 2. æ£€æŸ¥å¹¶è‡ªåŠ¨è¿ç§»æ—§æ•°æ® (å¦‚æœ memories è¡¨ç¼ºå°‘æ–°å­—æ®µ)
  try {
    const tableInfo = db.pragma("table_info(memories)");
    const hasScope = tableInfo.some((col: any) => col.name === "scope");
    if (!hasScope) {
      console.log("Migrating database to V3.0 schema...");
      const columns = [
        "ADD COLUMN scope TEXT DEFAULT 'local'",
        "ADD COLUMN project_id TEXT",
        "ADD COLUMN status TEXT DEFAULT 'active'",
        "ADD COLUMN parent_id TEXT",
        "ADD COLUMN change_reason TEXT",
        "ADD COLUMN source TEXT DEFAULT 'user'",
        "ADD COLUMN confidence REAL DEFAULT 1.0",
        "ADD COLUMN access_count INTEGER DEFAULT 0",
        "ADD COLUMN last_accessed_at INTEGER"
      ];
      for (const col of columns) {
        try { db.exec(`ALTER TABLE memories ${col};`); } catch (e) {}
      }
    }
  } catch (e) {
    console.error("Schema migration failed:", e);
  }

  // 3. å‘é‡è¡¨
  db.exec(`
    CREATE VIRTUAL TABLE IF NOT EXISTS vec_memories USING vec0(
      memory_id TEXT PRIMARY KEY,
      embedding FLOAT[${CONFIG.embeddingDimensions}]
    );
  `);

  return db;
}

function closeDB() {
  if (db) {
    try { db.pragma('wal_checkpoint(TRUNCATE)'); db.close(); } catch (e) {}
    db = null;
  }
}

async function getEmbedding(text: string): Promise<Float32Array> {
  await loadDependencies();
  if (!embeddingPipeline) {
    embeddingPipeline = await pipeline("feature-extraction", CONFIG.embeddingModel);
  }
  const output = await embeddingPipeline(text, { pooling: "mean", normalize: true });
  return new Float32Array(output.data);
}

// === æ ¸å¿ƒåŠŸèƒ½ï¼šV3.0 å­˜å‚¨ (æ”¯æŒæ¼”åŒ–) ===
interface MemoryOptions {
  tags?: string[];
  scope?: "global" | "local";
  projectId?: string;
  parentId?: string;      // å¦‚æœæ˜¯ä¿®æ”¹æ—§è®°å¿†ï¼Œä¼ å…¥æ—§ID
  changeReason?: string;  // ä¿®æ”¹ç†ç”±
  source?: string;
}

async function saveMemory(content: string, options: MemoryOptions = {}): Promise<string> {
  const database = await initDB();
  const id = `mem_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;
  const now = Date.now();
  
  const scope = options.scope || "local";
  const projectId = scope === "local" ? (options.projectId || "unknown") : null;
  const tagsStr = options.tags?.length ? options.tags.map(t => t.toLowerCase()).join(",") : null;

  // 1. å¦‚æœæŒ‡å®šäº† parentIdï¼Œå…ˆæŠŠæ—§è®°å¿†å½’æ¡£ (Evolution Logic)
  if (options.parentId) {
    database.prepare(`
      UPDATE memories 
      SET status = 'archived', updated_at = ?, change_reason = ?
      WHERE id = ?
    `).run(now, options.changeReason || "Superseded by new memory", options.parentId);
  }

  // 2. æ’å…¥æ–°è®°å¿†
  const embedding = await getEmbedding(content);
  const embeddingBuffer = Buffer.from(embedding.buffer);

  database.prepare(`
    INSERT INTO memories (
      id, content, tags, scope, project_id, status, parent_id, source, created_at, updated_at, last_accessed_at
    ) VALUES (?, ?, ?, ?, ?, 'active', ?, ?, ?, ?, ?)
  `).run(
    id, content, tagsStr, scope, projectId, options.parentId || null, options.source || "user_explicit", now, now, now
  );

  database.prepare(`
    INSERT INTO vec_memories (memory_id, embedding) VALUES (?, ?)
  `).run(id, embeddingBuffer);

  return id;
}

// === æ ¸å¿ƒåŠŸèƒ½ï¼šV3.0 æœç´¢ (å¸¦ Scope å’Œ Status è¿‡æ»¤) ===
async function searchMemories(query: string, projectId: string, limit: number = CONFIG.maxMemories) {
  const database = await initDB();
  const queryEmbedding = await getEmbedding(query);
  const queryBuffer = Buffer.from(queryEmbedding.buffer);

  // 1. å‘é‡æœç´¢æ‰¾å‡ºæœ€ç›¸ä¼¼çš„ N ä¸ª
  const vecResults = database.prepare(`
    SELECT memory_id, distance
    FROM vec_memories
    WHERE embedding MATCH ? AND k = ?
    ORDER BY distance
  `).all(queryBuffer, limit * 3); // å¤šå–ä¸€ç‚¹ï¼Œåé¢è¿˜è¦è¿‡æ»¤

  if (vecResults.length === 0) return [];

  // 2. å…³è”ä¸»è¡¨å¹¶è¿›è¡Œ Scope/Status è¿‡æ»¤
  // è§„åˆ™ï¼š(Status = active) AND (Scope = global OR (Scope = local AND ProjectID = current))
  const placeholders = vecResults.map(() => "?").join(",");
  const ids = vecResults.map((r: any) => r.memory_id);
  
  const rows = database.prepare(`
    SELECT * FROM memories 
    WHERE id IN (${placeholders})
    AND status = 'active'
    AND (scope = 'global' OR (scope = 'local' AND project_id = ?))
  `).all(...ids, projectId);

  // 3. åˆå¹¶ç»“æœå¹¶æ’åº
  const finalResults = rows.map((row: any) => {
    const vec = vecResults.find((v: any) => v.memory_id === row.id);
    return {
      ...row,
      distance: vec ? vec.distance : 1.0,
      similarity: vec ? Math.max(0, 1 - (vec.distance * vec.distance / 2)) : 0
    };
  })
  .filter((r: any) => r.distance <= CONFIG.maxDistance)
  .sort((a: any, b: any) => a.distance - b.distance) // è¶Šå°è¶Šç›¸ä¼¼
  .slice(0, limit);

  // 4. æ›´æ–°è¿™äº›è®°å¿†çš„â€œæ´»è·ƒåº¦â€ (Decay Logic)
  const hitIds = finalResults.map((r: any) => r.id);
  if (hitIds.length > 0) {
    const now = Date.now();
    const updatePlaceholders = hitIds.map(() => "?").join(",");
    database.prepare(`
      UPDATE memories 
      SET access_count = access_count + 1, last_accessed_at = ?
      WHERE id IN (${updatePlaceholders})
    `).run(now, ...hitIds);
  }

  return finalResults;
}

// === æ’ä»¶å¯¼å‡º ===
export default function (pi: any) {
  
  // å·¥å…· 1: å­˜è®°å¿† (å¢å¼ºç‰ˆ)
  pi.registerTool({
    name: "save_memory",
    description: "å°†ä¿¡æ¯å­˜å…¥é•¿æœŸè®°å¿†åº“ã€‚æ”¯æŒè‡ªåŠ¨å…³è”é¡¹ç›®ã€æ¼”åŒ–æ—§è®°å¿†ã€‚",
    parameters: Type.Object({
      content: Type.String({ description: "è¦è®°ä½çš„å†…å®¹" }),
      tags: Type.Array(Type.String(), { default: [], description: "æ ‡ç­¾" }),
      scope: Type.Optional(Type.String({ description: "'global' (é€šç”¨) æˆ– 'local' (å½“å‰é¡¹ç›®)ã€‚ä¸å¡«é»˜è®¤ä¸º localã€‚" })),
      previous_memory_id: Type.Optional(Type.String({ description: "å¦‚æœæ˜¯æ›´æ–°/ä¿®æ­£æ—§è®°å¿†ï¼Œè¯·å¡«å…¥æ—§è®°å¿†çš„ID" })),
      change_reason: Type.Optional(Type.String({ description: "ä¿®æ”¹/æ›´æ–°çš„ç†ç”±" }))
    }),
    async execute(id: string, params: any, signal: any, onUpdate: any, ctx: any) {
      try {
        const projectId = getProjectHash(ctx.cwd);
        const memId = await saveMemory(params.content, {
          tags: params.tags,
          scope: params.scope || "local", // é»˜è®¤ä¸º Localï¼Œé˜²æ­¢æ±¡æŸ“
          projectId: projectId,
          parentId: params.previous_memory_id,
          changeReason: params.change_reason,
          source: "user_explicit"
        });
        
        let msg = `âœ“ å·²å­˜å…¥è®°å¿† (ID: ${memId})`;
        if (params.previous_memory_id) msg += `\nâ™»ï¸ æ—§è®°å¿† ${params.previous_memory_id} å·²å½’æ¡£`;
        
        return { content: [{ type: "text", text: msg }], details: { id: memId } };
      } catch (error: any) {
        return { content: [{ type: "text", text: `Error: ${error.message}` }], isError: true };
      }
    }
  });

  // å·¥å…· 2: æœè®°å¿† (å¢å¼ºç‰ˆ)
  pi.registerTool({
    name: "search_memory",
    description: "æœç´¢è®°å¿†ã€‚ä¼šè‡ªåŠ¨æ ¹æ®å½“å‰é¡¹ç›®è¿‡æ»¤ç»“æœã€‚",
    parameters: Type.Object({
      query: Type.String({ description: "æœç´¢å…³é”®è¯" }),
      limit: Type.Optional(Type.Number())
    }),
    async execute(id: string, params: any, signal: any, onUpdate: any, ctx: any) {
      const projectId = getProjectHash(ctx.cwd);
      const results = await searchMemories(params.query, projectId, params.limit || 10);
      
      if (results.length === 0) return { content: [{ type: "text", text: "æ²¡æœ‰æ‰¾åˆ°ç›¸å…³è®°å¿†ã€‚" }] };

      const text = results.map((r: any, i: number) => 
        `[${r.id}] ${r.scope === 'global' ? 'ğŸŒ' : 'ğŸ '} (${Math.round(r.similarity*100)}%) ${r.content}`
      ).join("\n");

      return { content: [{ type: "text", text: `æ‰¾åˆ° ${results.length} æ¡ç›¸å…³è®°å¿†:\n${text}` }], details: { results } };
    }
  });

  // è‡ªåŠ¨æ³¨å…¥é€»è¾‘ (ç›‘å¬ + æ£€ç´¢)
  pi.on("before_agent_start", async (event: any, ctx: any) => {
    const projectId = getProjectHash(ctx.cwd);
    const prompt = event.prompt;
    
    // 1. è‡ªåŠ¨æœç´¢ç›¸å…³èƒŒæ™¯
    let contextSection = "";
    if (prompt && prompt.length >= 4) {
      try {
        const results = await searchMemories(prompt, projectId, 5);
        if (results.length > 0) {
          ctx.ui.setStatus("memory", `ğŸ§  è”æƒ³ (${results.length})`);
          contextSection = "\n\n### ğŸ§  MEMORY CONTEXT (å·²è‡ªåŠ¨æ£€ç´¢):\n" +
            results.map((m: any) => `- [${m.scope === 'global' ? 'Global' : 'Project'}] ${m.content} (ID:${m.id})`).join("\n") +
            "\n(è¯·åˆ©ç”¨ä¸Šè¿°è®°å¿†è¾…åŠ©å›ç­”ã€‚å¦‚æœç”¨æˆ·æŒ‡ä»¤ä¸è®°å¿†å†²çªï¼Œè¯·è¯¢é—®æ˜¯å¦éœ€è¦æ›´æ–°è®°å¿†ã€‚)";
        }
      } catch (e) {}
    }

    // 2. æ¤å…¥â€œæ½œæ„è¯†â€æŒ‡ä»¤ (å…³é”®æ­¥éª¤ï¼šè®© AI è‡ªåŠ¨ç®¡ç†è®°å¿†)
    const subconscious = `
### ğŸ§  MEMORY MANAGER PROTOCOL (AUTO-PILOT)
You are the guardian of the user's long-term memory. 
Current Project Hash: ${projectId}

**YOUR HIDDEN DUTY:**
While answering the user, you must SIMULTANEOUSLY maintain the memory database.
1. **Detect Insights**: If the user states a preference, a rule, or a decision, call \`save_memory\`.
   - If it applies everywhere (e.g., "I hate Java"), set \`scope: 'global'\`.
   - If it applies here (e.g., "Use port 8080"), set \`scope: 'local'\`.
2. **Detect Evolution**: If the user changes a rule (e.g., "Switch to PostgreSQL"), you MUST:
   - Search for the old memory ID using \`search_memory\`.
   - Call \`save_memory\` with \`previous_memory_id\` to archive the old one.
3. **Be Silent but Effective**: Do not ask "Should I remember this?". JUST DO IT. confirm with a subtle "âœ“ noted" in your response.
`;

    return {
      systemPrompt: (event.systemPrompt || "") + subconscious + contextSection
    };
  });

  // å¯åŠ¨æç¤º
  pi.on("session_start", async (_event: any, ctx: any) => {
    ctx.ui.notify("ğŸ§  V3.0 æ—¶ç©ºè®°å¿†ç³»ç»Ÿå·²ä¸Šçº¿ (Global/Local éš”ç¦» + è‡ªåŠ¨æ¼”åŒ–)", "info");
  });

  pi.on("session_shutdown", async () => closeDB());
}
